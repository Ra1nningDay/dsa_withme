// หลักการทำงานของ binary search คือจะเริ่มจากหาค่าที่อยู่ต่ำสุดและสูงสุดก่อน ซึ่งคือ 0 และ arr.length ซึ่งเป็นความยาวของ arr
// จากนั้นนำตัวเลขสองชุดมาหาค่ากลาง ไว้สำหรับหาค่าที่อยู่แต่ละฝั่งซึ่งอิงจากค่ามากกว่าน้อยกว่า
// สูตรหาค่าที่อยู่ตรงกลางของ arr คือ (lo + (hi + lo) / 2) เช่น 1 + (2+1) / 2 = 3/2 = 1.5 ซึ่งนับว่าเป็นค่ากลาง

//**  
// logic
// **//

//* ถ้าค่าที่ได้รับน้อยกว่าค่ากลาง การค้นหาจะไปโฟกัสฝั่งที่น้อยกว่าค่ากลาง ซึ่งตามหลักต้องลบลงไปจนเจอค่าที่ต้องการจะหา 
// แต่อันนี้ใช้วิธีโดยการเอาค่ากลางมาแทนค่า hi เพื่อที่ตอนวนลูปใหม่การค้นหาจะเริ่มต้นที่ค่าที่น้อยกว่าค่ากลางจนกว่าจะเจอค่าที่ต้องการหา

//* แต่ถ้าค่าที่ได้รับมากกว่าค่ากลาง การค้นหาก็จะไปโฟกัสฝั่งที่ค่ามากว่าค่ากลาง + 1 ขึ้นไปจนกว่าจะเจอ

export default function binary_serach(arr: number[], needle: number): boolean {
    let lo: number = 0;
    let hi: number = arr.length;
    let n: number = needle;

    do {
        let m = Math.floor(lo + (hi - lo) / 2);
        let v = arr[m];
        if (v === n) {
            return true;
        } else if (v > n) {
            hi = m; 
            // ถ้า needle น้อยกว่าค่ากลาง การค้นหาจะเริ่มจะลดช่วงลง ซึ่งน้อยกว่าค่ากลาง วนลูปลงไปจนกว่าจะเจอค่า
            // โลจิกคือ ถ้า hi = 6 ตอนที่ needle น้อยกว่า v ค่าของ hi ก็จะถูกเปลี่ยนเป็น m ซึ่งเท่ากับ 3 
            // ก่อนที่จะไปวนลูปแบบนั้นใหม่จะกว่าค่าจะน้อยลงจนเจอค่าที่เท่ากับ needle
        } else if (v < n) {
            lo = m + 1; //ถ้า needle มากกว่าค่ากลาง การค้นหาจะเริ่มจากตรงนี้โดยเพิ่มไปทีละ 1 จนกว่าจะเต็มเงื่อนไข while
        }
    } while (lo < hi);

    return false;
}

const number = [1, 2, 3, 4, 5];
console.log(binary_serach(number, 6));
